// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "vertexVersionCentroid.h"
#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		_centroid out vec2 uv0;
		_centroid out vec2 uv1;
	#endif
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif
#endif

#ifndef BYPASS_PIXEL_SHADER
	varying vec4 color;
	varying highp vec3 wpos;
	varying highp vec3 pp;
	varying float ng;
#endif

#ifdef LOW_PRECISION
	varying vec4 fogColor;
	varying vec4 fogCoIor;
	varying vec4 fogColor2;
  varying float moreFog;
  varying float fdif;
  varying float fray;
  varying vec4 fogRcolor;
	varying float rFog;
#endif

#include "uniformWorldConstants.h"
#include "uniformPerFrameConstants.h"
#include "uniformShaderConstants.h"
#include "uniformRenderChunkConstants.h"

attribute POS4 POSITION;
attribute vec4 COLOR;
attribute vec2 TEXCOORD_0;
attribute vec2 TEXCOORD_1;

const float rA = 1.0;
const float rB = 1.0;
const vec3 UNIT_Y = vec3(0,1,0);
const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange

void main()
{
    POS4 worldPos;
#ifdef AS_ENTITY_RENDERER
		POS4 pos = WORLDVIEWPROJ * POSITION;
		worldPos = pos;
#else
    worldPos.xyz = (POSITION.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
    worldPos.w = 1.0;

    // Transform to view space before projection instead of all at once to avoid floating point errors
    // Not required for entities because they are already offset by camera translation before rendering
    // World position here is calculated above and can get huge
    POS4 pos = WORLDVIEW * worldPos;
    pos = PROJ * pos;
#endif
    gl_Position = pos;
    
    pp = POSITION.xyz;
    wpos = worldPos.xyz;
    ng = pow(max(min(1.0-FOG_COLOR.r*1.5,1.0),0.0),1.2);
    

#ifndef BYPASS_PIXEL_SHADER
    uv0 = TEXCOORD_0;
    uv1 = TEXCOORD_1;
	color = COLOR;
#endif

///// find distance from the camera

#if defined(LOW_PRECISION) || defined(BLEND)
	#ifdef FANCY
		vec3 relPos = -worldPos.xyz;
		float cameraDepth = length(relPos.y)*clamp(-wpos.y+40.0,0.0,1.0);
	#else
		float cameraDepth = pos.z;
	#endif
#endif

vec3 wave = worldPos.xyz + VIEW_POS;

#ifdef ALPHA_TEST
 if(color.g > color.r)
 {
  gl_Position.x += sin(TIME * 4. + wave.x + wave.y + wave.z) *.03;
 }
#endif 

///// apply fog

float dd = pow(max(min(1.0-FOG_COLOR.b*1.2,1.0),0.0),0.5);
float ng = pow(max(min(1.0-FOG_COLOR.r*1.5,1.0),0.0),1.2);
float rd = smoothstep(0.6, 0.34, FOG_CONTROL.x);

vec4 dc = vec4(2.0,1.0,1.0, CURRENT_COLOR.a)*0.85;
vec4 nc = vec4(0.0,0.0,0.0, CURRENT_COLOR.a ) * 0.15;
vec4 sc = vec4(10.0,10.0,1.0, CURRENT_COLOR.a);
vec4 rc = vec4(1.5,1.5,1.5, CURRENT_COLOR.a)+vec4(-1.5,-1.5,-1.5, CURRENT_COLOR.a)*ng;
vec4 fog = mix(mix(mix(dc,sc,dd),nc,ng),rc,rd);	


#ifdef LOW_PRECISION
	float len = cameraDepth / RENDER_DISTANCE*0.;
	#ifdef ALLOW_FADE
		len += CURRENT_COLOR.r;
	#endif

    fogColor.rgb = FOG_COLOR.rgb*vec3(1.0,1.0,1.5);
    fogColor2.rgb = FOG_COLOR.rgb*vec3(1.8,1.1,0.9)+vec3(-1.8,0.6,0.9)*ng*(1.0-rd);
    fogCoIor = fog;
 
	fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 0.45);

vec3 rel = -worldPos.xyz*0.45-0.35*ng;
float tambahfog = length(rel.yz);
moreFog = tambahfog / FAR_CHUNKS_DISTANCE*0.5;

vec3 ray = -worldPos.xyz;
float rray = 1.0-length(ray.yz*0.02);
fray = clamp(rray,0.0,1.0)*length(-worldPos.x)/RENDER_DISTANCE*0.075;

vec3 dir = -worldPos.xyz*0.5-0.5*ng;
float dirf = length(dir.x);
fdif = dirf / FAR_CHUNKS_DISTANCE*0.5;

vec3 rain = -worldPos.xyz*1.15;
float vRain = length(rain.xz);
rFog = clamp(vRain / FAR_CHUNKS_DISTANCE*0.65,0.0,1.0)*rd;

fogRcolor.rgb = FOG_COLOR.rgb*(vec3(1.8,2.2,2.2)*1.26)*rd;
#endif

///// blended layer (mostly water) magic
#ifdef BLEND
	//Mega hack: only things that become opaque are allowed to have vertex-driven transparency in the Blended layer...
	//to fix this we'd need to find more space for a flag in the vertex format. color.a is the only unused part
	bool shouldBecomeOpaqueInTheDistance = color.a < 0.95;
	if(shouldBecomeOpaqueInTheDistance) {
		#ifdef FANCY  /////enhance water
			float cameraDist = cameraDepth / FAR_CHUNKS_DISTANCE;
			color = COLOR;
		#else
			// Completely insane, but if I don't have these two lines in here, the water doesn't render on a Nexus 6
			vec4 surfColor = vec4(color.rgb, 1.0);
			color = surfColor;
				
			vec3 relPos = -worldPos.xyz;
			float camDist = length(relPos);
			float cameraDist = camDist / FAR_CHUNKS_DISTANCE;
		#endif //FANCY
		
		float alphaFadeOut = clamp(cameraDist, 0.0, 1.0);
		color.a = mix(color.a, 1.0, alphaFadeOut);
	}
#endif

#ifndef BYPASS_PIXEL_SHADER
	#ifndef LOW_PRECISION
		// If the FOG_COLOR isn't used, the reflection on NVN fails to compute the correct size of the constant buffer as the uniform will also be gone from the reflection data
		color.rgb += FOG_COLOR.rgb * 0.000001;
	#endif
#endif
}